담당 : 혜정

# 변수

### 질문 리스트

- ✅변수와 식별자란 무엇인가요?
- ✅호이스팅이란 무엇인가요?
- ✅TDZ란 무엇인가요?

---

## 변수와 식별자란 무엇인가요?

변수(Variable)란 하나의 값을 저장하기 위해 확보한 메모리 공간 혹은 그 메모리 공간을 인식하기 위해 붙은 이름을 의미합니다.

![이미지](https://velog.velcdn.com/images%2Fnulbo%2Fpost%2Ff60655f1-9f85-45e1-9cf2-0d92daab4245%2F0.png)

컴퓨터는 여러 데이터와 연산 결과를 메모리에 저장해 두고, 필요할 때 꺼내서 쓸 수 있습니다. 메모리에 데이터가 저장되어 있다고 할 때, 그 값에 접근하기 위해 직접 메모리 주소로 접근하지 않습니다.

메모리에 직접 접근을 하지 않는 이유는,

1. 메모리 주소로 직접 접근할 때 만약 시스템과 관련있는 값을 변경할 경우 치명적 오류가 발생할 수 있고

2. 메모리 주소는 코드 실행 시 동적으로 할당되기 때문입니다. 즉 그때 그때 상황에 맞춰 변한다는 것입니다.

코드가 실행되기 전까지 메모리의 위치를 알 수도 없고, 안다고 해도 직접 접근하는 것은 위험하기 때문에 우리는 변수를 사용합니다.

변수는 메모리 공간을 인식하기 위한 매커니즘입니다. 메모리 공간에 어떠한 값을 저장하고, 그 값이 저장된 메모리 공간을 기억했다가 재사용 할 수 있습니다.

변수는 어떻게 이러한 일을 가능하게 하는걸까요? 이를 이해하려면 변수 이름 즉, 식별자(identifier)에 대한 이해가 필요합니다.

![이미지](https://d32gkk464bsqbe.cloudfront.net/DZY9OcrJM09VSi2oFRQl1pGJay4=/1000x600/contents/o/4d7d4b575eabad0400f1cd904d33bcd69e97ce9f.png)

식별자란, "식별할 수 있는 이름" 즉 값을 구별하고 식별할 수 있는 고유한 이름을 의미하는데요.

```javascript
const identifier = value;
```

변수를 선언할 때 좌측에 식별자를 선언하고 우측에 값을 할당하죠. 언뜻 보기에는 식별자가 바로 값을 기억하고 있을 것 같지만, 놀랍게도 그렇지 않습니다.

식별자는 값이 저장된 메모리 주소를 기억하고 있기 때문이죠.

![이미지](https://obj-sg.thewiki.kr/data/65787465726e616c2f322e62702e626c6f6773706f742e636f6d2f427565636865726b756275732d6131383837323730322e6a7067.jpg)

엄청나게 큰 도서관이 있다고 생각해보세요. 거기서 제가 찾고 싶은 'a'라는 책이 있다고 합시다.

![이미지](https://libapps-au.s3-ap-southeast-2.amazonaws.com/accounts/53184/images/%ED%9D%AC%EB%A7%9D%EB%8F%84%EC%84%9C2.png)

책을 찾기 위한 가장 쉬운 방법은 도서 검색 시스템으로 책 이름을 검색한 뒤, 위치를 찾아가면 되겠죠. 도서관 안에서는 도서의 이름 'a'도 일종의 식별자가 된다고 볼 수 있습니다.

![이미지](https://mblogthumb-phinf.pstatic.net/20160407_234/ymtechwin_14599948073397QI2P_JPEG/P20160406_162555620_FB8E1B9D-ACD1-4006-8041-68BEC0662ECF.JPG?type=w2)

또 다른 식별자로는 도서 라벨이 있을텐데요. 도서관에 종사하지 않는 저희로서는 알기 힘들 수 있지만, 도서 분류와 위치 정보를 함축적으로 담고있어 다른 도서와 식별할 수 있는 식별자의 예시가 될 수 있겠습니다.

어떤 도서를 찾기 위해 매번 '2층 3열 54번째 책장 7번째 칸 몇 번째에 위치해 있습니다....' 이렇게 설명하면 말하는 사람도 듣는 사람도 지치겠죠?

이렇듯 식별자는 다른 값과 구별될 수 있으면서, 메모리 주소와 맵핑 관계를 맺고 있기 때문에 값이 저장된 메모리 주소를 기억하고 있습니다.

## 호이스팅과 TDZ

![이미지](https://cranes.or.kr/data/ebslider/basic3/3ffa8647e2f98535376bd5d2890352bf.jpg)

변수 혹은 함수 선언문이 코드 상단으로 끌어올려진 것 같은 현상을 의미합니다.

조금 더 쉽게 설명하자면, 아래와 같은 코드가 있을 때 (놀랍게도) 에러가 발생하지 않는 것입니다.

```javascript
console.log(score); // undefined

var score = 100;
```

저는 이 코드에서 두 가지 놀라운 점을 발견했는데요.

하나는 선언문 이전에 변수에 접근했는데 에러가 발생하지 않았다는 것.

두번째는 제가 할당해준 100이라는 값이 아닌 undefined가 출력되었다는 것입니다!

먼저 이러한 현상은 자바스크립트의 고유한 현상인데요. 소스코드가 런타임 이전에 컴파일 과정을 거치면서 선언문을 먼저 실행시켰기 때문입니다.

제가 앞서 작성한 코드가 실행되기 전에, 자바스크립트 엔진은 이 코드를 한 번 슥 훑으면서 실행을 위한 준비를 하는데요.

이 단계에서 제가 선언한 score 라는 변수의 선언이 실행되었기 때문에, 진짜 실행 단계에서 접근을 해도 에러가 발생하지 않는 것입니다.

이 것은 자바스크립트의 고유한 현상이기 때문에 `var, let, const, function, function\*(제너레이터), class` 의 키워드를 사용하는 모든 식별자들은 호이스팅이 발생합니다.

함수 호이스팅의 경우 적절히 활용하면 유용할 수 있지만, 변수 호이스팅은 그렇지 않은데요. 바로 아래와 같은 일이 일어날 수 있기 때문입니다.

```javascript
score = 30;
console.log(score); //30

var score = 100;
```

뭔가 많이 이상하죠? 선언 이전에 참조를 했는데 아무런 제지가 없고 심지어 값을 할당까지 할 수 있다면 코드가 어떻게 돌아갈지 예측을 할 수가 없습니다.

이러한 문제점은 var 키워드의 문제점이기도 한데요. var 키워드를 사용한 변수는 호이스팅은 물론 위 코드처럼 값의 할당까지 가능합니다. 또 아래와 같은 일도 일어날 수 있죠.

```javascript
var score = 30;
var score = 100;

console.log(score); //100
```

![이미지](https://kjpn062.cafe24.com/web/product/big/201707/107_shop1_770273.jpg)

이런 ~~망나니~~ 유연하고 열린 사고를 가진 var 키워드는 우리 코드에서 문제를 일으킬 가능성이 높습니다. 그래서 ES6에서는 이를 보완하기 위해 `let` 과 `const` 키워드를 도입했죠.

```javascript
console.log(score);
// TDZ
// ReferenceError: Cannot access 'score' before initialization
let score = 30;
```

해석하자면 score는 초기화 되기 전에는 접근할 수 없다는 것입니다. 앞서 자바스크립트의 특성으로 `let` 과 `const`를 포함한 모든 식별자는 코드 실행 전 선언이 된다고 했었죠.

`var` 과 `let`, `const` 의 차이는 선언 시점과 초기화 시점이 다르다는 것입니다. 앞서 `var score = 30` 이전에 score 변수에 접근하여 `undefined` 값을 얻었던 이유는, 선언과 동시에 `undefined`로 초기화가 되었기 때문입니다.

이렇게 `let` 그리고 `const` 로 선언한 변수는 함수 호이스팅이 되어도 접근할 수 없는 TDZ : Temporal Dead Zone 일시적 사각지대가 있습니다.

그리고 TDZ는 let과 const로 선언된 함수 표현식에도 영향을 줄 수 있습니다.

```javascript
console.log(foo()); // TDZ
const foo = () => {
  return 'hello world';
};
```
